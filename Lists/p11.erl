-module(p11).
-export([encode_modified/1]).

encode_modified(List) -> encodemod(List, []).

% Последующий пункт совпадает с предыдущим. Инкрементируем его количество в промежуточном списке
encodemod([H|T], [{I,H}|List])->
	encodemod(T, [{I+1,H}|List]);
% Последующий пункт не совпадает с предыдущим, потому что это вообще первый пункт. В список вывода пустой промежуточный список не добавляем
encodemod([H|T], []) ->
	encodemod(T, [{1,H}]);
% Последующий пункт не совпадает с предыдущим, а предыдущий был только один - вот она, модификация
encodemod([H|T], [{1,X}|List])->
	encodemod(T, [{1,H},X|List]);
% Последующий пункт не совпадает с предыдущим - добавляем промежуточный список к списку вывода
encodemod([H|T], List)->
	encodemod(T, [{1,H}|List]);
% Всё закончено, списки пусты - выводим
encodemod([], List)->
	p05:reverse(List).
